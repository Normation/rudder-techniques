#####################################################################################
# Copyright 2011 Normation SAS
#####################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, Version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#####################################################################################

#
# Just bodies and editbundles here
#
############################################
#perms validation
body perms p(user,mode) {
  owners => { "$(user)" };
  mode   => "$(mode)";
}

############################################

body file_select cf3_files {
  leaf_name => { "cf-.*" };
  file_result => "leaf_name";
}



#########################################################

body changes lay_trip_wire {
  hash           => "best";
  report_changes => "content";
  update_hashes  => "yes";
}

########################################################

body action longjob {
ifelapsed => "240"; # run only every 4 hours
}

#######################################################
# For the library
#######################################################

body edit_defaults noempty_backup
{
empty_file_before_editing => "false";
edit_backup => "timestamp";  # we want to keep a track of everything
max_file_size => "1024000";
}

body edit_defaults empty_backup
{
empty_file_before_editing => "true";
edit_backup => "timestamp";
max_file_size => "1024000";
}


body edit_defaults def_no_backup
{
empty_file_before_editing => "false";
edit_backup => "false";
max_file_size => "1024000";
}
########################################################



########################################################

bundle edit_line DeleteLinesMatching(regex) {
  delete_lines:

    "$(regex)",
  action => WarnOnly;

}

########################################################

body action WarnOnly {
  action_policy => "warn";
}

########################################
# Bodies
########################################

body replace_with With(x)

{
replace_value => "$(x)";
occurrences => "all";
}

########################################

################################
# For commands with a >
################################
body contain outputable
{
useshell => "true";
no_output=> "false";
}

################################
# For commands with a >, in a dir
################################
body contain outputable_dir(dir)
{
useshell => "true";
no_output=> "false";
chdir => "$(dir)";
}

################################
# Process is launched ?
################################
body process_count islaunched(class) {
  match_range => irange("1", "500");
  in_range_define => { "$(class)"};
  out_of_range_define => {"no_$(class)"};
}


###########################################################################################
# Persistent class
# If the promise is repaired, define repaired for length minutes and undefine failed
# If the promise is not kept, undefine repaired and define failed for length minutes
##########################################################################################
body classes persistant_class(repaired, failed, length) {
  promise_repaired => { "$(repaired)" };
  repair_failed    => { "$(failed)" };
  repair_denied    => { "$(failed)" };
  repair_timeout   => { "$(failed)" };
  
  cancel_repaired => {"$(failed)"};
  cancel_notkept => {"$(repaired)"};
  
  persist_time => "$(length)";
}



###########################################################################################
# Persistent class
# If the promise is repaired/kept, define repaired for length minutes and undefine failed
# If the promise is not kept, undefine repaired and define failed for length minutes
##########################################################################################
body classes set_persist_classes(repaired, failed, length) {
  promise_kept 	   => { "$(repaired)" };
  promise_repaired => { "$(repaired)" };
  repair_failed    => { "$(failed)" };
  repair_denied    => { "$(failed)" };
  repair_timeout   => { "$(failed)" };
  
  cancel_kept => {"$(failed)"};
  cancel_repaired => {"$(failed)"};
  cancel_notkept => {"$(repaired)"};
   
  persist_time => "$(length)";
}

################################################
# kept_if_else
# set kept if the promise is kept
# yes if repaired
# no if cannot repair
################################################
body classes kept_if_else(kept, yes,no)

{
promise_kept     => { "$(kept)" };
promise_repaired => { "$(yes)" };
repair_failed    => { "$(no)" };
repair_denied    => { "$(no)" };
repair_timeout   => { "$(no)" };
}


#########################################
# Make a local copy with a digest check #
#########################################
body copy_from digest_cp(from)
{
source            => "$(from)";
compare           => "digest";
copylink_patterns => { ".*" };
}

################################################
# Special kept_if_else
# set kept if the promise is kept
# yes if repaired
# no if cannot repair
# Trigger an additionnal promise if repaired
################################################
body classes kept_if_else_hook(kept,yes,no,hook)

{
promise_kept     => { "$(kept)" };
promise_repaired => { "$(yes)", "$(hook)" };
repair_failed    => { "$(no)" };
repair_denied    => { "$(no)" };
repair_timeout   => { "$(no)" };
}

################################################
# Simple group adjustment body
################################################
body perms group(group)
{
        groups => { "${group}" };
}


################################################
# Same as recurse but without xdev
# and including the current dir
################################################
body depth_search recurse_with_current(d)

{
depth => "$(d)";
include_basedir => "true";
xdev  => "false";
}

########################################################################
# Mount an NFS share, and allow the user to select if it is persistent #
########################################################################
body mount rudder_nfs(server,source,type,persistence)
{
mount_type => "$(type)";
mount_source => "$(source)";
mount_server => "$(server)";
edit_fstab => "$(persistence)";
}

########################################################################
# Same as std_defs, allowing user to specify the file erase policy     #
########################################################################
body edit_defaults rudder_empty_select(select)
{
empty_file_before_editing => "$(select)";
max_file_size => "1024000";
edit_backup => "timestamp";
}

########################################################################
# Handle a directory recursively, including the dir itself             #
########################################################################
body depth_search recurse_withroot(d)
{
depth => "$(d)";
# xdev  => "true";
include_basedir => "true";
}

########################################################################
# Change group and mode of a file/directory                            #
########################################################################
body perms mg(mode,group)
{
groups => { "$(group)" };
mode   => "$(mode)";
}

########################################################################
# Select a file using a date AND a pattern                             #
########################################################################
body file_select date_pattern(age, pattern)
{
	mtime       => irange("0", ago(0,0,"$(age)",0,0,0));
	leaf_name   => { "$(pattern)" };

	file_result => "leaf_name.mtime";
}

########################################################################
# Install a package using rug                                          #
########################################################################
body package_method rudder_rug {

	package_changes => "individual";

	package_list_command => "/bin/rpm -qa --queryformat \"i | repos | %{name} | %{version}-%{release} | %{arch}\n\"";
	package_patch_list_command => "/usr/bin/rug patches";
	package_list_update_ifelapsed => "240";
	package_installed_regex => "i.*";
	package_list_name_regex    => "[^|]+\|[^|]+\|\s+([^\s]+).*";
	package_list_version_regex => "[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
	package_list_arch_regex    => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";

	package_patch_installed_regex => ".*Installed.*|.*Not Applicable.*";
	package_patch_name_regex    => "[^|]+\|\s+([^\s]+).*";
	package_patch_version_regex => "[^|]+\|[^|]+\|\s+([^\s]+).*";

	package_name_convention => "$(name)";
	package_add_command => "/usr/bin/rug install -y";
	package_delete_command => "/usr/bin/rug remove -y";
	package_update_command => "/usr/bin/rug update -y";

#Unsure about the behavior of this command ...
#package_patch_command => "/usr/bin/rug patch-info";
package_verify_command => "/usr/bin/rug verify -y$"; # $ means no args
}
